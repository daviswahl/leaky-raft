#![feature(futures_api, arbitrary_self_types, await_macro, async_await, proc_macro_hygiene)]
use futures::{
    compat::TokioDefaultSpawner,
    future::{self, Ready},
    prelude::*,
};

use tarpc::server::Handler;
use std::io;

use tarpc_bincode_transport as bincode_transport;

mod rpc;
mod server;

async fn run() -> io::Result<()> {
    // bincode_transport is provided by the associated crate bincode-transport. It makes it easy
    // to start up a serde-powered bincode serialization strategy over TCP.
    let transport = bincode_transport::listen(&"0.0.0.0:0".parse().unwrap())?;
    let addr = transport.local_addr();

    // The server is configured with the defaults.
    let server = tarpc::server::new(tarpc::server::Config::default())
        // Server can listen on any type that implements the Transport trait.
        .incoming(transport)
        // Close the stream after the client connects
        .take(1)
        // serve is generated by the service! macro. It takes as input any type implementing
        // the generated Service trait.
        .respond_with(crate::rpc::serve(crate::server::HelloServer));

    tokio_executor::spawn(server.unit_error().boxed().compat());

    let transport = await!(bincode_transport::connect(&addr))?;

    // new_stub is generated by the service! macro. Like Server, it takes a config and any
    // Transport as input, and returns a Client, also generated by the macro.
    // by the service mcro.
    let mut client = await!(crate::rpc::new_stub(tarpc::client::Config::default(), transport))?;

    // The client has an RPC method for each RPC defined in service!. It takes the same args
    // as defined, with the addition of a Context, which is always the first arg. The Context
    // specifies a deadline and trace information which can be helpful in debugging requests.
    let hello = await!(client.hello(tarpc::context::current(), "Stim".to_string()))?;

    println!("{}", hello);

    Ok(())
}

fn main() {
    tarpc::init(TokioDefaultSpawner);
    tokio::run(run()
                   .map_err(|e| eprintln!("Oh no: {}", e))
                   .boxed()
                   .compat(),
    );
}